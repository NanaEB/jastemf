#summary JastEMF examples: SIPLE tutorial.

= Tutorial Introduction =

In this tutorial we will present SIPLE --- a simple imperative programming language --- and generate different SIPLE implementations, each with additional language tooling:

 * *JastAdd Version:* A standard compiler implemented based on [http://jflex.de/ JFlex], [http://beaver.sourceforge.net/ Beaver] and JastAdd.
 * *[#EMF_Version EMF Version]:* A compiler with an EMF repository implemented based on JFlex, Beaver, JastAdd and JastEMF.
 * *[#EMFText_Version EMFText Version]:* A compiler with EMF repository and an Eclipse editor with syntax highlighting, code completion and semantic property view implemented based on [http://www.emftext.org EMFText] (including [http://www.antlr.org/ ANTLR]), JastAdd and JastEMF.

Of course, our main focus is on the EMF integrated versions. The tutorial will not only describe how to generate these using JastEMF, but also how to use the semantic metamodel implementation and what it benefits are. The JastAdd version, which represents an ordinary compiler project without any reference to metamodelling and the EMF, is used for validation issues. Its SIPLE compiler and the EMF integrated one share the same JastAdd specifications for SIPLE's semantics and are compared by a [#Regression_Tests regression test suite], to show, that the integration performed by JastEMF is correct.

== A First Look on SIPLE ==

To get an impression of SIPLE, consider the following programm given in concrete syntax:
{{{
Procedure main() Begin
    Write fibunacci(10);
    Write mr(10);
End;

Procedure fibunacci(Var n:Integer):Integer Begin
    Var result:Integer;
    If (n > 1) 
        Then result := fibunacci(n-1) + fibunacci(n-2);
    Else
        result := 1;
    Fi;
    Return result;
End;

Procedure mr(Var n:Integer) Begin
    Procedure mr1(Var lb:Integer, Var ub:Integer) Begin
        If lb >= 0 Then
            Write lb;
            mr2(lb - 1, ub);
        Fi;
    End;
    
    Procedure mr2(Var lb:Integer, Var ub:Integer) Begin
        Write ub;
        mr1(lb, ub + 1);
    End;	
    
    mr1(n, n);
End;
}}}
It consists of two procedures. The first computes the well-known [http://en.wikipedia.org/wiki/Fibonacci_number Fibunacci numbers] and the second writes, starting from a natural number, a sequence of its predecessors and successors. In the end the program prints out the Fibunacci number of `10` and the sequence `10, 10, 9, 11, 8, 12, 7, 13, 6, 14, 5, 15, 4, 16, 3, 17, 2, 18, 1, 19, 0, 20`.

= Deployment and Configuration =

= Project Repository Overview =

Before we investigate how to generate and use the different SIPLE versions, let us take a short look on the project's structure. The project consists of four relevant resources. First, there is the actual *SIPLE implementation* in the _"implementation"_ source code folder. As expected, most of it will be generated later on. Its general package structure is as follows:
 * _siple_: Contains a simple _Interpreter_ class to execute SIPLE programs from command line. It expects only one argument --- the program file to interpret. Given a program to interpret the class just instantiates a SIPLE parser and lexer, which are used to produce the program's model. Afterwards, the model itself is executed by calling its execution semantics.
 * _siple.semantics.\*_: This packages contain generated 

= EMF Version =

= EMFText Version =

= Regression Tests =

= Summary =