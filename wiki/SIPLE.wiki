#summary JastEMF examples: SIPLE tutorial.

= Tutorial Introduction =

In this tutorial we will present SIPLE --- a simple imperative programming language --- and generate different SIPLE implementations, each with additional language tooling:

 * *JastAdd Version:* A standard compiler implemented based on [http://jflex.de/ JFlex], [http://beaver.sourceforge.net/ Beaver] and JastAdd.
 * *[#EMF_Version EMF Version]:* A compiler with an EMF repository implemented based on JFlex, Beaver, JastAdd and JastEMF.
 * *[#EMFText_Version EMFText Version]:* A compiler with EMF repository and an Eclipse editor with syntax highlighting, code completion and semantic property view implemented based on [http://www.emftext.org EMFText] (including [http://www.antlr.org/ ANTLR]), JastAdd and JastEMF.

Of course, our main focus is on the EMF integrated versions. The tutorial will not only describe how to generate these using JastEMF, but also how to use the semantic metamodel implementation and what its benefits are. The JastAdd version, which represents an ordinary compiler project without any reference to metamodelling and the EMF, is used for validation issues. Its SIPLE compiler and the EMF integrated one share the same JastAdd specifications for SIPLE's semantics and are compared by a [#Regression_Tests regression test suite], to show, that the integration performed by JastEMF is correct.

For all SIPLE versions the same concrete syntax is supported. Also, all SIPLE versions have the same static semantics, including a nested block structured name analysis supporting nested procedure declarations and lexic scopes (closures) and a strong type analysis. Additionally, all SIPLE versions support the interpretation of programs, whereas only the JastAdd and EMF versions support an appropriate command line interface to execute programs via invocation from command line. Last but not least, the JastAdd and EMF versions are [#Regression_Tests regression tested] to each other to validate JastEMF's correctness.

== A First Look on SIPLE ==

To get an impression of SIPLE, consider the following programm given in concrete syntax:
{{{
Procedure main() Begin
    Write fibunacci(10);
    Write mr(10);
End;

Procedure fibunacci(Var n:Integer):Integer Begin
    Var result:Integer;
    If (n > 1) 
        Then result := fibunacci(n-1) + fibunacci(n-2);
    Else
        result := 1;
    Fi;
    Return result;
End;

Procedure mr(Var n:Integer) Begin
    Procedure mr1(Var lb:Integer, Var ub:Integer) Begin
        If lb >= 0 Then
            Write lb;
            mr2(lb - 1, ub);
        Fi;
    End;
    
    Procedure mr2(Var lb:Integer, Var ub:Integer) Begin
        Write ub;
        mr1(lb, ub + 1);
    End;	
    
    mr1(n, n);
End;
}}}
It consists of two procedures. The first computes the well-known [http://en.wikipedia.org/wiki/Fibonacci_number Fibunacci numbers] and the second writes, starting from a natural number, a sequence of its predecessors and successors. In the end the program prints out the Fibunacci number of `10` and the sequence `10, 10, 9, 11, 8, 12, 7, 13, 6, 14, 5, 15, 4, 16, 3, 17, 2, 18, 1, 19, 0, 20`.

= Deployment and Configuration =

= Project Repository Overview =

Before we investigate how to generate and use the different SIPLE versions, let us take a short look on the project's structure. The project consists of four relevant resources. First, there is the actual *SIPLE implementation* in the _"implementation"_ source code folder. As expected, most of it will be generated later on. Its general package structure is as follows:

 * _siple_: Contains a simple `Interpreter` class to execute SIPLE programs from command line. It expects only one argument --- the program file to interpret. Given a program to interpret the class just instantiates a SIPLE parser and lexer, which are used to produce the program's model. Afterwards, the model itself is executed by calling its execution semantics. *Note:* Command line interpretation is not supported for the EMFText version.
 * _siple.semantics.`*`_: These packages contain the generated semantic metamodel implementation and handwritten helper classes, like `State` and `Type` which represent interpreter states and SIPLE types respectively.
 * _siple.symbols_: Package containing generated artefacts for lexic analysis. *Note:* The EMFText version has no explicit lexic analysis. Its lexic and sytactic analysis are realised as separate Eclipse plugins.
 * _siple.syntax_: Package containing generated artefacts for syntactic analysis. *Note:* The EMFText version's syntactic analysis is realised as separate Eclipse plugins.
 * _jastemf.adaptation_: Package containing integration artefacts generated by JastEMF. These artefacts are not required at the SIPLE compiler's runtime. They are only stored for convenient reasons for developers interested which changes exactly JastEMF performed. Of course, only the EMF and EMFText versions require a JastEMF integration.
 * _rtt.adaptation_: Package containing artefacts required for regression testing via [http://st.inf.tu-dresden.de/rtt RTT]. Since RTT's integration depends on the generated SIPLE version, the package content is generated. *Note:* Regression testing is only supported for the JastAdd and EMF versions.

To generate the desired SIPLE implementation, of course, appropriate specifications are required. Thus, the second important project resource are *SIPLE's specifications*, contained in the _"specifications/siple"_ folder. Each kind of specification has its own subfolder. The respective concerns are SIPLE's _model_, its _semantics_, its _syntax_ and its _symbols_. Except the semantics, each folder's content is self-explanatory. The semantics are separated w.r.t. SIPLE's different semantic concerns, which are name analysis, type analysis, data flow analysis, interpretation and helper methods subsumed in the access support concern. To declare all these concerns a so called compiler _core_ is defined, which specifies the functionallity each concern must support, i.e. the compiler core declares all supported semantics whereas each concern's `*.jrag` specification specifies it.

= EMF Version =

= EMFText Version =

= Regression Tests =

= Summary =