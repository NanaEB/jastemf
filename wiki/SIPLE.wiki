#summary JastEMF examples: SIPLE tutorial.

<wiki:toc max_depth="2" />

= Tutorial Introduction =

In this tutorial we will present SIPLE --- a simple imperative programming language --- and generate different SIPLE implementations, each with additional language tooling:

 * *[#JastAdd_Version JastAdd Version]:* A standard compiler implemented based on [http://jflex.de/ JFlex], [http://beaver.sourceforge.net/ Beaver] and [http://www.jastadd.org/ JastAdd].
 * *[#EMF_Version EMF Version]:* A compiler with an EMF repository implemented based on JFlex, Beaver, JastAdd and JastEMF.
 * *[#EMFText_Version EMFText Version]:* A compiler with EMF repository and an Eclipse editor with syntax highlighting, code completion and semantic property view implemented based on [http://www.emftext.org EMFText] (including [http://www.antlr.org/ ANTLR]), JastAdd and JastEMF.

Of course, our main focus is on the EMF integrated versions. The tutorial will not only describe how to generate these using JastEMF, but also how to use the semantic metamodel implementation and what its benefits are. The JastAdd version, which represents an ordinary compiler project without any reference to metamodelling and the EMF, is used for validation issues. Its SIPLE compiler and the EMF integrated one share the same JastAdd specifications for SIPLE's semantics and are compared by a [#Regression_Tests regression test suite], to show, that the integration performed by JastEMF is correct.

For all SIPLE versions the same concrete syntax is supported. Also, all SIPLE versions have the same static semantics, including a nested block structured name analysis supporting nested procedure declarations and lexic scopes (closures) and a strong type analysis. Additionally, all SIPLE versions support the interpretation of programs, whereas only the JastAdd and EMF versions support an appropriate command line interface to execute programs via invocation from command line. Last but not least, the JastAdd and EMF versions are [#Regression_Tests regression tested] to each other to validate JastEMF's correctness.

== A First Look on SIPLE ==

To get an impression of SIPLE, consider the following programm given in concrete syntax:
{{{
Procedure main() Begin
    Write fibunacci(10);
    Write mr(10);
End;

Procedure fibunacci(Var n:Integer):Integer Begin
    Var result:Integer;
    If (n > 1) Then
        result := fibunacci(n-1) + fibunacci(n-2);
    Else
        result := 1;
    Fi;
    Return result;
End;

Procedure mr(Var n:Integer) Begin
    Procedure mr2(Var lb:Integer, Var ub:Integer);
    
    Procedure mr1(Var lb:Integer, Var ub:Integer) Begin
        If lb >= 0 Then
            Write lb;
            mr2(lb - 1, ub);
        Fi;
    End;
    
    Procedure mr2(Var lb:Integer, Var ub:Integer) Begin
        Write ub;
        mr1(lb, ub + 1);
    End;	
    
    mr1(n, n);
End;
}}}
It consists of two procedures. The first computes the well-known [http://en.wikipedia.org/wiki/Fibonacci_number Fibunacci numbers] and the second writes, starting from a natural number, a sequence of its predecessors and successors. In the end the program prints out the Fibunacci number of `10` and the sequence `10, 10, 9, 11, 8, 12, 7, 13, 6, 14, 5, 15, 4, 16, 3, 17, 2, 18, 1, 19, 0, 20`.

= Deployment and Configuration =

== Installation ==

The SIPLE tutorial can be checked out from the project's SVN repository. It is named _"calculator"_ and a subfolder of _"jastemf-examples"_. It is recommended to check it out within Eclipse, e.g. using [http://subclipse.tigris.org/ Subclipse].

To install Subclipse use its Eclipse update site via _Help => Install new Software => Work with: "http://subclipse.tigris.org/update_1.6.x" =>_ select the required components _=> Next =>_ ... _=> Finish_. After installation, make sure that the correct SVN interface is configurated (_Window => Preferences => Team => SVN => SVN interface:_ Usually it should be the _"SVNKit (Pure Java)" => Apply => OK_).

The EMFText SIPLE version additionally requires the [http://www.emftext.org EMFText] plugin to be deployed. The required libraries are in the _"sources/applications/emftext-plugins"_ folder. Just copy them into your Eclipse's _"dropins"_ folder and restart Eclipse.

Last but not least, [http://st.inf.tu-dresden.de/rtt RTT] is used to regression test the EMF SIPLE version against the JastAdd version. RTT's `jar` distribution is already contained in and referenced by the project. However, the integration of RTT is done using [http://www.eclipse.org/aspectj/ AspectJ]. Thus, the [http://www.eclipse.org/ajdt/ AspectJ Development Tools] for Eclipse are required. Just install them via their update site _"http://download.eclipse.org/tools/ajdt/35/update"_ as described for Subclipse above.

The following table summarises the tools used by the SIPLE project, their purpose, whether they must be manually installed or configurated and if they are already contained in the project's repository:

|| *Tool* || *Purpose* || *Must be Installed* || *Shiped with SIPLE* ||
|| [http://subclipse.tigris.org/ Subclipse] || To check out the project from its SVN || Yes || No ||
|| JastEMF || To integrate JastAdd semantics into EMF metamodel implementations || [Installation Yes] || Yes ||
|| [http://www.emftext.org EMFText] || Required to generate the EMFText SIPLE version || Yes || Yes ||
|| [http://www.eclipse.org/ajdt/ AspectJ] || To weave regression test support into the JastAdd and EMF SIPLE versions || Yes || No ||
|| [http://st.inf.tu-dresden.de/rtt RTT] || Regression test tool || No || Yes ||
|| [http://beaver.sourceforge.net/ Beaver] || LALR(1) parsergenerator || No || Yes ||
|| [http://jflex.de/ JFlex] || Lexer generator || No || Yes ||

== Configuration ==

After checking out SIPLE, deploying EMFText and installing the Eclipse AspectJ tools no further configurations are required. The different SIPLE versions can be immediately generated using [http://ant.apache.org/ Ant] build scripts. It is only important to remember, that all build scripts must be executed within the JRE in which Eclipse is executed.

To execute a build script within the same JRE, select _Run => External Tools => External Tool Configurations =>_ double click _Ant Build =>_ give the script a name and select it (_Buildfile:_ e.g. `${workspace_loc:/calculator/specifications/siple/build.xml}`) _=> JRE => Run in the same JRE as the workspace => Apply_. Of course, also the desired target has to be selected under the _Targets_ tab. In SIPLE's case it is also recommended to automatically refresh and build the workspace after generation (_Refresh => The project containing the selected resource => Recoursively include sub-folders_ should be selected; _Build => The project containing the selected resource_).

Further steps, how to deploy and use generated implementations, are given in the respective version's description.

= Project Repository Overview =

Before we investigate how to generate and use the different SIPLE versions, let us take a short look on the project's structure. The project consists of four relevant resources:

 * SIPLE implementation (source code folder _"implementation"_)
 * SIPLE specifications (folder _"specifications"_)
 * SIPLE regression tests (folder _"tests"_)
 * Required libraries and other resources (folder _"sources"_)

The following screenshot gives an impression of the example's repository:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_structure.png

== Implementation ==

The actual *SIPLE implementation* is in the _"implementation"_ source code folder. Most of it will be generated as shown later. Its general package structure is as follows:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_implementation.png

 * _siple_: Contains a simple `Interpreter` class to execute SIPLE programs from command line. It expects only one argument --- the program file to interpret. Given a program to interpret the class just instantiates a SIPLE parser and lexer, which are used to produce the program's model. Afterwards, the model itself is executed by calling its execution semantics. *Note:* Command line interpretation is not supported for the EMFText version.
 * _siple.semantics.`*`_: These packages contain the generated semantic metamodel implementation and handwritten helper classes, like `State` and `Type` which represent interpreter states and SIPLE types respectively.
 * _siple.symbols_: Package containing generated artefacts for lexic analysis. *Note:* The EMFText version has no explicit lexic analysis. Its lexic and sytactic analysis are realised as separate Eclipse plugins.
 * _siple.syntax_: Package containing generated artefacts for syntactic analysis. *Note:* The EMFText version's syntactic analysis is realised as separate Eclipse plugins.
 * _jastemf.adaptation_: Package containing integration artefacts generated by JastEMF. These artefacts are not required by the implementation, i.e. they are not required at runtime. They are only stored for convenient reasons for developers interested which changes exactly JastEMF performed. Of course, only the EMF and EMFText versions are generated by JastEMF.
 * _rtt.adaptation_: Package containing artefacts required for regression testing via [http://st.inf.tu-dresden.de/rtt RTT]. Since RTT's integration depends on the generated SIPLE version, the package content is generated. *Note:* Regression testing is only supported for the JastAdd and EMF versions.

== Specifications ==

To generate the desired SIPLE implementation, of course, appropriate specifications are required. Thus, the second important project resource are *SIPLE's specifications*, which are in the _"specifications/siple"_ folder. The specifcations are grouped w.r.t. different implementation concerns. For each concern an equal named folder containing all its specifications exists:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_specifications.png

 * _model_: Specification of the SIPLE compiler's API --- i.e. its metamodel (_siple.ecore_) --- and how to generate an appropriate EMF implementation (_siple.genmodel_). Also a diagram of the metamodel is given (_siple.ecorediag_). *Note:* Only the EMF and EMFText version have an Ecore metamodel.
 * _semantics_: Specification of the SIPLE compiler's static semantics and its interpreter functionallities (dynamic/execution semantics). The semantics are separated w.r.t. SIPLE's different semantic concerns, which are name analysis, type analysis, data flow analysis, interpretation and helper methods subsumed in the access support concern. To declare all these concerns a so called compiler core is defined, which specifies the functionallity each concern must support, i.e. the compiler core declares all supported semantics whereas each concern's JastAdd specification (the _`*`.jrag_ files) specifies it.
 * _syntax_: Specification of the SIPLE compiler's parser. In the JastAdd and EMF version a LALR(1) Beaver parser is used (_parser.beaver_). The EMFText version is based on an LL(`*`) ANTLR parser, which is generated based on an EMFText concrete syntax definition (_siple.cs_) and uses a handwritten token resolver class (`ExprTYPETokenResolver.java`) to transform the strings `Boolean`, `Integer` and `Real` into their respective SIPLE types (`siple.semantics.Type`).
 * _symbols_: Specification of the SIPLE compiler's lexer (_lexer.jflex_). *Note:* Only the JastAdd and EMF version require an explicit lexer specification.

The generation process of a SIPLE version from its respective specifications is steered by a single [http://ant.apache.org/ Ant] build script (_"build.xml"_). Each SIPLE version can be generated using a equal named task. To clean up generated artefacts the `Clean` task can be used. *Important:* The build script must be executed within the JRE in which Eclipse is executed (For details see [#Configuration above]).

== Tests ==

Another important project resource are test programs that check SIPLE's implementation, especially the correctness of its static semantics. All artefacts related to testing are contained in the _"tests"_ folder, which consists of three subfolders:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_tests.png

 * _adaptation_: Contains AspectJ aspects, that prepare the JastAdd and EMF version's implementation for regression tests with RTT. The respective adaptation aspects are copied verbatim into the `rtt.adaptation` package while generating a concrete SIPLE version.
 * _source`_`code`_`examples_: Contains example SIPLE programs used for testing. The programs are classified, whether they are correct or contain static semantic errors. Each program (i.e. testcase) tests a certain aspect of the SIPLE language. All example programs are packed together into a single RTT testsuite.
 * _testsuites_: Contains the RTT testsuite against which the JastAdd and EMF versions are regression tested.

Similar to the generation of a SIPLE implementation from its specifications, also the generation, updating and execution of SIPLE's RTT testsuite is steered by a single Ant build script (_"build.xml"_ in the _"tests"_ directory). Again, the build script must be executed within the JRE in which Eclipse is executed (For details see [#Configuration above]).

== Libraries and other Resources ==

The last important project resource are third party libraries SIPLE depends and which are shipped with it (For a summary of each library's purpose see the table [#Installation above]). They are contained in sub folders of the _"sources"_ directory:

https://jastemf.googlecode.com/svn/wiki/Examples/SIPLE/repository_sources.png

 * _libraries_: Contains `jar` libraries explicitely called by SIPLE's Ant build scripts or on which SIPLE's implementation depends on.
 * _applications_: Contains third party applications that have to be installed manually as described [#Installation above]. If for any of the _libraries_ folder's `jar` a more comprehensive end user distribution exists, also it is contained.
 * _support_: Contains support artefacts, that ease the development of SIPLE and SIPLE programs in third party tools (e.g. [http://www.textpad.com/ TextPad] syntax highlighting specifications).

= JastAdd Version =

The first SIPLE implementation we investigate has a straightforward compiler construction approach. It consist of a generated lexer, a generated LALR(1) parser, a generated attributed abstract syntax tree (AST) and a generated attribute evaluator. The attribute evaluator is part of the AST --- i.e. the AST implementation contains the semantics implementation. The lexer is specified by a single [http://jflex.de/ JFlex] specification (_"specifications/siple/symbols/lexer.jflex"_), the parser by a single [http://beaver.sourceforge.net/ Beaver] specification (_"specifcations/siple/syntax/parser.beaver"_) and the AST by several [http://www.jastadd.org/ JastAdd] AST and `jrag` specifications (_"specifications/siple/semantics/"_`*`_"_). As known from compiler construction, it is the lexer's purpose to transform a stream of characters (an input program) into a stream of tokens, it is the parser's purpose to transform the stream of tokens into an AST and is the attribute evaluator's purpose to evaluate the AST's semantics. Since we like to show in this tutorial how JastAdd reference attribute grammars (RAGs) can be used to specify Ecore metamodel semantics, our focus is on SIPLE's semantics.

As mentioned before, the semantics are part of the AST generated by JastAdd. For each specified AST node type a equal named class is generated --- i.e. the AST implementation is an object oriented class hierarchy --- and each attribute becomes a method of the class representing the node type it is associated with. If an attribute's method is called, its semantics are evaluated. Thus, JastAdd generates demand driven RAG evaluators and the compiler's API are the AST classes' attribute methods. Besides attributes for static semantics, also methods for interpretation purpose are specified for SIPLE and woven by JastAdd into the AST. These methods are based on the specified static semantics and are part of the semantic specifications. Thus, interpretation is not done on a special intermediate representation, but rather on the AST. In contrast, e.g. to Java and the JVM, where the JVM does interpret bytecode programs and not Java source code programs, SIPLE's interpreter is executed on the source code's AST. Therefore, it is no problem to instantiate its lexer and parser, let them construct a program's AST and just invoke the AST root node's `Interpretation` attribute to execute the program. A default implementation performing exactly these steps is the `siple.Interpreter` class's `main(String[] args)` method, which expects as single argument the path of the program file to interpret.

== Interpretation of SIPLE Programs via Command Line ==

= EMF Version =

== Editing SIPLE Programs as Models via generated Eclipse Model Editors ==

= EMFText Version =

== Editing SIPLE Programs as Models in a generated Eclipse Text Editor ==

= Regression Tests =

SIPLE's different language constructs are systematically tested.

= Summary =