#summary JastEMF examples: SIPLE tutorial.

<wiki:toc max_depth="2" />

= Tutorial Introduction =

In this tutorial we will present SIPLE --- a simple imperative programming language --- and generate different SIPLE implementations, each with additional language tooling:

 * *[#JastAdd_Version JastAdd Version]:* A standard compiler implemented based on [http://jflex.de/ JFlex], [http://beaver.sourceforge.net/ Beaver] and JastAdd.
 * *[#EMF_Version EMF Version]:* A compiler with an EMF repository implemented based on JFlex, Beaver, JastAdd and JastEMF.
 * *[#EMFText_Version EMFText Version]:* A compiler with EMF repository and an Eclipse editor with syntax highlighting, code completion and semantic property view implemented based on [http://www.emftext.org EMFText] (including [http://www.antlr.org/ ANTLR]), JastAdd and JastEMF.

Of course, our main focus is on the EMF integrated versions. The tutorial will not only describe how to generate these using JastEMF, but also how to use the semantic metamodel implementation and what its benefits are. The JastAdd version, which represents an ordinary compiler project without any reference to metamodelling and the EMF, is used for validation issues. Its SIPLE compiler and the EMF integrated one share the same JastAdd specifications for SIPLE's semantics and are compared by a [#Regression_Tests regression test suite], to show, that the integration performed by JastEMF is correct.

For all SIPLE versions the same concrete syntax is supported. Also, all SIPLE versions have the same static semantics, including a nested block structured name analysis supporting nested procedure declarations and lexic scopes (closures) and a strong type analysis. Additionally, all SIPLE versions support the interpretation of programs, whereas only the JastAdd and EMF versions support an appropriate command line interface to execute programs via invocation from command line. Last but not least, the JastAdd and EMF versions are [#Regression_Tests regression tested] to each other to validate JastEMF's correctness.

== A First Look on SIPLE ==

To get an impression of SIPLE, consider the following programm given in concrete syntax:
{{{
Procedure main() Begin
    Write fibunacci(10);
    Write mr(10);
End;

Procedure fibunacci(Var n:Integer):Integer Begin
    Var result:Integer;
    If (n > 1) Then
        result := fibunacci(n-1) + fibunacci(n-2);
    Else
        result := 1;
    Fi;
    Return result;
End;

Procedure mr(Var n:Integer) Begin
    Procedure mr2(Var lb:Integer, Var ub:Integer);
    
    Procedure mr1(Var lb:Integer, Var ub:Integer) Begin
        If lb >= 0 Then
            Write lb;
            mr2(lb - 1, ub);
        Fi;
    End;
    
    Procedure mr2(Var lb:Integer, Var ub:Integer) Begin
        Write ub;
        mr1(lb, ub + 1);
    End;	
    
    mr1(n, n);
End;
}}}
It consists of two procedures. The first computes the well-known [http://en.wikipedia.org/wiki/Fibonacci_number Fibunacci numbers] and the second writes, starting from a natural number, a sequence of its predecessors and successors. In the end the program prints out the Fibunacci number of `10` and the sequence `10, 10, 9, 11, 8, 12, 7, 13, 6, 14, 5, 15, 4, 16, 3, 17, 2, 18, 1, 19, 0, 20`.

= Deployment and Configuration =

== Installation ==

The SIPLE tutorial can be checked out from the project's SVN repository. It is named _"calculator"_ and a subfolder of _"jastemf-examples"_. It is recommended to check it out within Eclipse, e.g. using [http://subclipse.tigris.org/ Subclipse].

To install Subclipse use its Eclipse update site via _Help => Install new Software => Work with: "http://subclipse.tigris.org/update_1.6.x" =>_ select the required components _=> Next =>_ ... _=> Finish_. After installation, make sure that the correct SVN interface is configurated (_Window => Preferences => Team => SVN => SVN interface:_ Usually it should be the _"SVNKit (Pure Java)" => Apply => OK_).

The EMFText SIPLE version additionally requires the [http://www.emftext.org EMFText] plugin to be deployed. The required libraries are in the _"sources/applications/emftext-plugins"_ folder. Just copy them into your Eclipse's _"dropins"_ folder and restart Eclipse.

Last but not least, [http://st.inf.tu-dresden.de/rtt RTT] is used to regression test the EMF SIPLE version against the JastAdd version. RTT's `jar` distribution is already contained in and referenced by the project. However, the integration of RTT is done using [http://www.eclipse.org/aspectj/ AspectJ]. Thus, the [http://www.eclipse.org/ajdt/ AspectJ Development Tools] for Eclipse are required. Just install them via their update site _"http://download.eclipse.org/tools/ajdt/35/update"_ as described for Subclipse above.

The following table summarises the tools used by the SIPLE project, their purpose, whether they must be manually installed or configurated and if they are already contained in the project's repository:

|| *Tool* || *Purpose* || *Must be Configurated/Installed* || *Shiped with SIPLE* ||
|| Subclipse || To check out the project from its SVN within Eclipse || Yes || No ||
|| EMFText || Required to generate the EMFText SIPLE version || Yes || Yes ||
|| AspectJ || To weave regression test support into the JastAdd and EMF SIPLE versions || Yes || No ||
|| RTT || Regression Test Tool || No || Yes ||
|| Beaver || LALR(1) parsergenerator || No || Yes ||
|| JFlex || Lexer generator || No || Yes ||

== Configuration ==

After checking out SIPLE, deploying EMFText and installing the Eclipse AspectJ tools no further configurations are required. The different SIPLE versions can be immediately generated using [http://ant.apache.org/ Ant] build scripts. It is only important to remember, that all build scripts must be executed within the JRE in which Eclipse is executed.

To execute a build script within the same JRE, select _Run => External Tools => External Tool Configurations =>_ double click _Ant Build =>_ give the script a name and select it (_Buildfile:_ e.g. `${workspace_loc:/calculator/specifications/siple/build.xml}`) _=> JRE => Run in the same JRE as the workspace => Apply_. Of course, also the desired target has to be selected under the _Targets_ tab. In SIPLE's case it is also recommended to automatically refresh and build the workspace after generation (_Refresh => The project containing the selected resource => Recoursively include sub-folders_ should be selected; _Build => The project containing the selected resource_).

Further steps, how to deploy and use generated implementations, are given in the respective version's description.

= Project Repository Overview =

Before we investigate how to generate and use the different SIPLE versions, let us take a short look on the project's structure. The project consists of four relevant resources. 

== Implementation ==

First, there is the actual *SIPLE implementation* in the _"implementation"_ source code folder. Most of it will be generated as shown later. Its general package structure is as follows:

 * _siple_: Contains a simple `Interpreter` class to execute SIPLE programs from command line. It expects only one argument --- the program file to interpret. Given a program to interpret the class just instantiates a SIPLE parser and lexer, which are used to produce the program's model. Afterwards, the model itself is executed by calling its execution semantics. *Note:* Command line interpretation is not supported for the EMFText version.
 * _siple.semantics.`*`_: These packages contain the generated semantic metamodel implementation and handwritten helper classes, like `State` and `Type` which represent interpreter states and SIPLE types respectively.
 * _siple.symbols_: Package containing generated artefacts for lexic analysis. *Note:* The EMFText version has no explicit lexic analysis. Its lexic and sytactic analysis are realised as separate Eclipse plugins.
 * _siple.syntax_: Package containing generated artefacts for syntactic analysis. *Note:* The EMFText version's syntactic analysis is realised as separate Eclipse plugins.
 * _jastemf.adaptation_: Package containing integration artefacts generated by JastEMF. These artefacts are not required by the implementation, i.e. they are not required at runtime. They are only stored for convenient reasons for developers interested which changes exactly JastEMF performed. Of course, only the EMF and EMFText versions are generated by JastEMF.
 * _rtt.adaptation_: Package containing artefacts required for regression testing via [http://st.inf.tu-dresden.de/rtt RTT]. Since RTT's integration depends on the generated SIPLE version, the package content is generated. *Note:* Regression testing is only supported for the JastAdd and EMF versions.

== Specifications ==

To generate the desired SIPLE implementation, of course, appropriate specifications are required. Thus, the second important project resource are *SIPLE's specifications*, which are in the _"specifications/siple"_ folder. The specifcations are grouped w.r.t. different implementation concerns. For each concern an equal named folder containing all its specifications exists:

 * _model_: Specification of the SIPLE compiler's API --- i.e. its metamodel (_siple.ecore_) --- and how to generate an appropriate EMF implementation (_siple.genmodel_). Also a diagram of the metamodel is given (_siple.ecorediag_). *Note:* Only the EMF and EMFText version have an Ecore metamodel.
 * _semantics_: Specification of the SIPLE compiler's static semantics and its interpreter functionallities (dynamic/execution semantics). The semantics are separated w.r.t. SIPLE's different semantic concerns, which are name analysis, type analysis, data flow analysis, interpretation and helper methods subsumed in the access support concern. To declare all these concerns a so called compiler core is defined, which specifies the functionallity each concern must support, i.e. the compiler core declares all supported semantics whereas each concern's JastAdd specification (the _`*`.jrag_ files) specifies it.
 * _syntax_: Specification of the SIPLE compiler's parser. In the JastAdd and EMF version a LALR(1) Beaver parser is used (_parser.beaver_). The EMFText version is based on an LL(`*`) ANTLR parser, which is generated based on an EMFText concrete syntax definition (_siple.cs_) and uses a handwritten token resolver class (`ExprTYPETokenResolver.java`) to transform the strings `Boolean`, `Integer` and `Real` into their respective SIPLE types (`siple.semantics.Type`).
 * _symbols_: Specification of the SIPLE compiler's lexer (_lexer.jflex_). *Note:* Only the JastAdd and EMF version require an explicit lexer specification.

The generation process of a SIPLE version from its respective specifications is steered by a single [http://ant.apache.org/ Ant] build script (_build.xml_). Each SIPLE version can be generated using a equal named task. To clean up generated artefacts the `Clean` task can be used. *Important:* The build script must be executed within the JRE in which Eclipse is executed (For details see [#Configuration above]).

== Tests ==

== Libraries and other Resources ==

= JastAdd Version =

== Interpretation of SIPLE Programs via Command Line ==

= EMF Version =

== Editing SIPLE Programs as Models via generated Eclipse Model Editors ==

= EMFText Version =

== Editing SIPLE Programs as Models in a generated Eclipse Text Editor ==

= Regression Tests =

= Summary =