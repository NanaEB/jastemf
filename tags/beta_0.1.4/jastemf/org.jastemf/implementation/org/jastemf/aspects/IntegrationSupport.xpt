«REM»
	This program and the accompanying materials are made available under the
	terms of the BSD 3-clause license which accompanies this distribution.
«ENDREM»
«EXTENSION org::jastemf::aspects::io»
«IMPORT ecore»
«IMPORT genmodel»

«REM»
	Template to generate runtime support classes required by integration
	artefacts.
	@author C. Bürger
«ENDREM»
«DEFINE Main(String astPackage, String outPackage) FOR GenModel»
«FILE asDirectory(astPackage) + "Exceptions.java"-»
/**
 * Generated by JastEMF [«timeStamp()»]
 */
package «astPackage»;

/**
 * <i>JastEMF</i> specific {@link java.lang.RuntimeException runtime
 * exceptions} used to signal implementation errors w.r.t.
 * <i>JastAdd's</i> API.
 * @author C. Bürger
 */
public class Exceptions {
	/**
	 * Construct an exception that indicates the removal of an AST node's
	 * child, which is not permitted since the node is not a <i>JastAdd</i>
	 * list.
	 * @param parent The node from which a child is removed.
	 * @param index The index of the removed child.
	 * @return An exception representing the illegal remove.
	 */
	public static JastEMFException illegalRemove(
			ASTNode<?> parent, int index) {
		return new JastEMFException(
				"JastAdd AST Manipulation Error\n"+
				"\tCause : Removing ["+index+"]'th child of ["+parent+"].\n"+
				"\tReason: ["+parent+"] is not a list.");
	}
	
	/**
	 * Construct an exception that indicates the insertion of a child into an
	 * AST node, which is not permitted since the node is not a <i>JastAdd</i>
	 * list.
	 * @param parent The node into which a child is inserted.
	 * @param index The index for which it has been tried to insert a child.
	 * @return An exception representing the illegal insert.
	 */
	public static JastEMFException illegalInsert(
			ASTNode<?> parent, int index, ASTNode<?> child) {
		return new JastEMFException(
				"JastAdd AST Manipulation Error\n"+
				"\tCause : Inserting ["+child+"] at position ["+index+
				"] in ["+parent+"].\n"+
				"\tReason: ["+parent+"] is not a list.");
	}
	
	private static class JastEMFException extends RuntimeException {
		static final long serialVersionUID = 1L;
		private JastEMFException(String message) {
			super(message);
		}
	}
}

«ENDFILE-»

«FILE asDirectory(outPackage) + "JastEMFAnnotations.java"-»
/**
 * Generated by JastEMF [«timeStamp()»]
 */
package «outPackage»;

import java.lang.annotation.*;

/**
 * Container class for integration related annotations.
 * @author C. Bürger
 */
public class JastEMFAnnotations {
	/**
	 * Annotation for methods and fields generated by <i>JastEMF</i> that
	 * replace already existing implementations to satisfy <i>EMF</i> or
	 * <i>JastAdd</i> related API constraints, which the original constructs
	 * failed. Consequently, such annotated constructs realize their twin's
	 * task -- they are a copy cat -- and replace their twin -- they are
	 * cannibalic.
	 * @author C. Bürger
	 */
	@Target({ElementType.METHOD, ElementType.FIELD})
	@Retention(RetentionPolicy.SOURCE)
	public static @interface CannibalicCopycat {}
	
	/**
	 * Internal <i>JastEMF</i> annotation for methods and fields to delete.
	 * Any field or method with the same name/signature and within the same
	 * class as the annotated element will be deleted. Thus, the annotated
	 * element copies an existing field/method -- it is a copy cat -- and its
	 * task is to delete the element it copies and itself -- it is a suicide.
	 * @author C. Bürger
	 */
	@Target({ElementType.METHOD, ElementType.FIELD})
	@Retention(RetentionPolicy.SOURCE)
	public static @interface SuicideCopycat {}
	
	/**
	 * Internal <i>JastEMF</i> annotation for methods that will be replaced
	 * by the method the annotation's value represents. Thus, the annotated
	 * method -- i.e. its signature and implementation -- will mutate.
	 * @author C. Bürger
	 */
	@Target(ElementType.METHOD)
	@Retention(RetentionPolicy.SOURCE)
	public static @interface MutatingMethod {
		String value();
	}
}

«ENDFILE»
«ENDDEFINE»
